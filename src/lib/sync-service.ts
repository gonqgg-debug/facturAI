/**
 * Sync Service Module
 * 
 * Handles bidirectional synchronization between local Dexie database
 * and Supabase cloud backend.
 * 
 * Features:
 * - Push local changes to Supabase
 * - Pull remote changes from Supabase
 * - Background sync at configurable intervals
 * - Conflict resolution (last-write-wins)
 * - Offline support with change tracking
 */

import { browser } from '$app/environment';
import { getSupabase, TABLE_NAME_MAP, SYNCED_TABLES, setStoreContext, type Database } from './supabase';
import { getStoreId, getDeviceId, getDeviceToken, isDeviceRegistered } from './device-auth';
import { 
    setSyncState, 
    setPendingChanges, 
    setSyncProgress,
    recordPush,
    recordPull,
    recordSyncFailure,
    setLastSyncTimestamp,
    getLastSyncTimestamp,
    markDeviceRegistered,
    markDeviceNotRegistered
} from './sync-store';
import { db, type MinimarketDatabase } from './db';

// ============================================================
// TYPES
// ============================================================

export interface PendingChange {
    id?: number;
    tableName: string;
    recordId: string;
    action: 'insert' | 'update' | 'delete';
    data: Record<string, unknown>;
    timestamp: number;
    synced?: boolean;
}

interface SyncResult {
    success: boolean;
    pushed: number;
    pulled: number;
    errors: string[];
}

// ============================================================
// CONFIGURATION
// ============================================================

const SYNC_INTERVAL_MS = 30000; // 30 seconds (realtime handles most updates)
const MAX_BATCH_SIZE = 100; // Max records per batch
const RETRY_DELAY_MS = 5000; // Retry after 5 seconds on failure

// Tables that use auto-increment local IDs (++id) instead of UUIDs
// These require special handling: map local_id in Supabase to id in Dexie
const AUTO_INCREMENT_TABLES = [
    'shifts',
    'users',
    'localRoles',
    'transactionFeatures',
    'realTimeInsights'
];

// Check if a table uses auto-increment IDs
function isAutoIncrementTable(tableName: string): boolean {
    return AUTO_INCREMENT_TABLES.includes(tableName);
}

// Tables with special unique constraints (not just 'id')
// Maps Supabase table name to the conflict columns for upsert
const TABLE_UNIQUE_CONSTRAINTS: Record<string, string> = {
    'itbis_summaries': 'store_id,period',      // Unique on store_id + period
    'ncf_ranges': 'store_id,type,prefix',      // Unique on store_id + type + prefix  
    'ncf_usage': 'store_id,ncf',               // Unique on store_id + ncf
    'receipt_settings': 'store_id',            // One per store
    'cost_consumptions': 'id'                  // UUID primary key (ensure it exists)
};

// Get the conflict key for a table's upsert operation
function getConflictKey(supabaseTableName: string, isAutoIncrement: boolean): string {
    // Check for special unique constraints first
    if (TABLE_UNIQUE_CONSTRAINTS[supabaseTableName]) {
        return TABLE_UNIQUE_CONSTRAINTS[supabaseTableName];
    }
    // Auto-increment tables use store_id + local_id
    if (isAutoIncrement) {
        return 'store_id,local_id';
    }
    // Default to id for UUID-based tables
    return 'id';
}

// ============================================================
// FIELD EXCLUSION SYSTEM
// ============================================================
// Fields that should NEVER be sent to Supabase (auto-generated by DB or don't exist)
// These are in snake_case (post-conversion) format

/**
 * Common fields excluded from ALL tables
 * - created_at: Auto-generated by Supabase DEFAULT NOW()
 * - updated_at: Auto-generated by Supabase trigger
 * - realm_id: Local Dexie multi-tenant field, not in Supabase
 */
const COMMON_EXCLUDED_FIELDS = [
    'created_at',
    'updated_at', 
    'realm_id'
];

/**
 * Table-specific field exclusions (snake_case)
 * Maps Supabase table names to arrays of fields that should NOT be sent
 * 
 * These handle cases where:
 * - TypeScript has fields that don't exist in Supabase
 * - Fields have different names in TypeScript vs Supabase
 * - Computed/virtual fields that shouldn't be synced
 */
const TABLE_FIELD_EXCLUSIONS: Record<string, string[]> = {
    // ============================================================
    // IMPORTANT: After applying migration 015_sync_schema_alignment.sql,
    // most exclusions have been removed because Supabase now has all columns.
    // ============================================================
    
    // inventory_lots: cost_includes_tax exists in Supabase but not TypeScript
    'inventory_lots': [
        'cost_includes_tax'  // Supabase has this, TypeScript doesn't
    ],
    
    // cost_consumptions: type and notes exist in Supabase but not TypeScript
    'cost_consumptions': [],
    
    // itbis_summaries: All fields now exist after migration 015
    'itbis_summaries': [],
    
    // journal_entries: lines is now JSONB in Supabase after migration 015
    'journal_entries': [],
    
    // Users/Roles: Only exclude sensitive fields
    'users': ['password_hash'],  // Never send password hashes
    'roles': [],
    
    // shifts: All fields now exist after migration 015
    // shift_number is now TEXT in Supabase (no conversion needed)
    'shifts': [],
    
    // suppliers: address_2 now exists after migration 015
    'suppliers': []
};

/**
 * Field name mappings for special cases where camelCase → snake_case isn't straightforward
 * Maps: { dexieTableName: { camelCaseField: 'snake_case_field' } }
 * 
 * After migration 015, most mappings are standard camelCase → snake_case conversions.
 * Only non-standard mappings are listed here.
 */
const FIELD_NAME_MAPPINGS: Record<string, Record<string, string>> = {
    // inventory_lots: Ensure correct naming
    'inventoryLots': {
        'lotNumber': 'lot_number',
        'originalQuantity': 'original_quantity',
        'remainingQuantity': 'remaining_quantity',
        'unitCostIncTax': 'unit_cost_inc_tax'
    },
    // cost_consumptions: Standard mappings
    'costConsumptions': {
        'lotId': 'lot_id',
        'totalCost': 'total_cost'
    },
    // itbis_summaries: After migration 015, all columns exist
    // Standard camelCase → snake_case works for most fields
    'itbisSummaries': {
        // Standard conversions handled automatically:
        // itbis18Collected -> itbis_18_collected
        // itbis16Collected -> itbis_16_collected
        // totalItbisCollected -> total_itbis_collected
        // netItbisDue -> net_itbis_due
        // etc.
    },
    // card_settlements: Ensure correct naming
    'cardSettlements': {
        'saleIds': 'sale_ids',
        'reconciledAt': 'reconciled_at'
    }
};

/**
 * Get fields to exclude for a specific table (snake_case names)
 */
function getExcludedFields(supabaseTableName: string): string[] {
    const tableSpecific = TABLE_FIELD_EXCLUSIONS[supabaseTableName] || [];
    return [...COMMON_EXCLUDED_FIELDS, ...tableSpecific];
}

/**
 * Get field name mapping for a Dexie table
 */
function getFieldMapping(dexieTableName: string): Record<string, string> {
    return FIELD_NAME_MAPPINGS[dexieTableName] || {};
}

// ============================================================
// DATA SANITIZATION UTILITIES
// ============================================================

/**
 * Known invalid UUID placeholder values that should be converted to null
 */
const INVALID_UUID_PLACEHOLDERS = [
    'LEGACY_NO_LOT', 
    'NONE', 
    'NULL', 
    'UNDEFINED', 
    '',
    'N/A',
    'NA',
    'TBD',
    'UNKNOWN'
];

/**
 * Check if a value is a valid UUID
 */
function isValidUUID(str: string): boolean {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(str);
}

/**
 * Sanitize a single field value for Supabase
 * Returns the sanitized value or undefined to indicate the field should be removed
 */
function sanitizeFieldValue(key: string, value: unknown): unknown {
    // Handle undefined - should be removed
    if (value === undefined) {
        return undefined;
    }
    
    // Handle null - keep as null (Supabase accepts null)
    if (value === null) {
        return null;
    }
    
    // Handle Date objects - convert to ISO string
    if (value instanceof Date) {
        return value.toISOString();
    }
    
    // Handle UUID fields (fields ending with _id except store_id)
    if (typeof value === 'string' && key.endsWith('_id') && key !== 'store_id') {
        const upperValue = value.toUpperCase().trim();
        
        // Check for invalid placeholder values
        if (INVALID_UUID_PLACEHOLDERS.includes(upperValue)) {
            return null;
        }
        
        // Check if it's a valid UUID or a numeric ID
        if (value.length > 0 && !isValidUUID(value) && !/^\d+$/.test(value)) {
            // Invalid format - convert to null
            console.log(`[Sync] Cleaned invalid UUID value in ${key}: "${value}" -> null`);
            return null;
        }
    }
    
    // Handle arrays - ensure they're serializable
    if (Array.isArray(value)) {
        try {
            JSON.stringify(value);
            return value;
        } catch {
            return [];
        }
    }
    
    // Handle objects - ensure they're serializable
    if (typeof value === 'object' && value !== null) {
        try {
            JSON.stringify(value);
            return value;
        } catch {
            return {};
        }
    }
    
    // Handle numbers - check for overflow/invalid values
    if (typeof value === 'number') {
        if (!Number.isFinite(value)) {
            return 0;
        }
        // Cap at 12 digits to prevent overflow
        if (Math.abs(value) > 999999999999) {
            console.warn(`[Sync] Capped large number in ${key}: ${value}`);
            return value > 0 ? 999999999999 : -999999999999;
        }
    }
    
    // Handle strings - trim whitespace, handle empty strings
    if (typeof value === 'string') {
        const trimmed = value.trim();
        // Don't convert empty strings to null for non-ID fields
        return trimmed;
    }
    
    // Return value as-is for other types
    return value;
}

/**
 * Sanitize an entire data object for Supabase
 * @param data The data object to sanitize
 * @param tableName Optional table name for enhanced logging
 * @param enableLogging Whether to log sanitization details (default: false)
 */
function sanitizeDataForSupabase(
    data: Record<string, unknown>, 
    tableName?: string,
    enableLogging: boolean = false
): Record<string, unknown> {
    const sanitized: Record<string, unknown> = {};
    const removedFields: string[] = [];
    const modifiedFields: Array<{key: string; from: unknown; to: unknown}> = [];
    
    for (const [key, value] of Object.entries(data)) {
        const sanitizedValue = sanitizeFieldValue(key, value);
        
        // Track removed fields
        if (sanitizedValue === undefined) {
            removedFields.push(key);
            continue;
        }
        
        // Track modified fields
        if (sanitizedValue !== value) {
            modifiedFields.push({ key, from: value, to: sanitizedValue });
        }
        
        sanitized[key] = sanitizedValue;
    }
    
    // Log sanitization results if enabled or if there were issues
    if (enableLogging || removedFields.length > 0 || modifiedFields.length > 0) {
        const tableInfo = tableName ? ` for ${tableName}` : '';
        if (removedFields.length > 0) {
            console.log(`[Sync] Removed fields${tableInfo}:`, removedFields);
        }
        if (modifiedFields.length > 0) {
            console.log(`[Sync] Modified fields${tableInfo}:`, 
                modifiedFields.map(m => `${m.key}: ${JSON.stringify(m.from)} -> ${JSON.stringify(m.to)}`));
        }
    }
    
    return sanitized;
}

/**
 * Log sync operation details for debugging
 */
function logSyncOperation(
    operation: 'push' | 'pull',
    tableName: string,
    recordId: string,
    action: string,
    data: Record<string, unknown>,
    result?: { success: boolean; error?: string }
): void {
    const fields = Object.keys(data);
    const summary = {
        operation,
        table: tableName,
        record: recordId,
        action,
        fieldCount: fields.length,
        fields: fields.slice(0, 10).join(', ') + (fields.length > 10 ? '...' : '')
    };
    
    if (result?.success === false) {
        console.error(`[Sync] FAILED ${operation}:`, summary, 'Error:', result.error);
    } else {
        console.log(`[Sync] ${operation}:`, summary);
    }
}

// ============================================================
// SYNC SERVICE CLASS
// ============================================================

class SyncService {
    private syncInterval: ReturnType<typeof setInterval> | null = null;
    private isSyncing = false;
    private isInitialized = false;
    
    /**
     * Initialize the sync service
     */
    async initialize(): Promise<void> {
        if (!browser || this.isInitialized) return;
        
        // Check if device is registered
        const deviceToken = getDeviceToken();
        const storeId = getStoreId();
        
        if (deviceToken && storeId) {
            markDeviceRegistered();
            this.isInitialized = true;
            
            // Check if this is a first sync (no lastSync timestamp)
            const isFirstSync = !getLastSyncTimestamp();
            
            if (isFirstSync) {
                console.log('[Sync] First sync detected - will pull all data');
            }
            
            // Initial sync
            await this.sync();
            
            // Start background sync
            this.startBackgroundSync();
        } else {
            markDeviceNotRegistered();
        }
    }
    
    /**
     * Start background synchronization
     */
    startBackgroundSync(): void {
        if (!browser) return;
        
        // Clear existing interval
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
        }
        
        // Remove existing listener before adding to prevent duplicates
        window.removeEventListener('online', this.handleOnline);
        
        // Set up periodic sync
        this.syncInterval = setInterval(() => {
            this.sync().catch(console.error);
        }, SYNC_INTERVAL_MS);
        
        // Sync when coming back online
        window.addEventListener('online', this.handleOnline);
        
        console.log('Background sync started');
    }
    
    /**
     * Stop background synchronization
     */
    stopBackgroundSync(): void {
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
        
        if (browser) {
            window.removeEventListener('online', this.handleOnline);
        }
        
        console.log('Background sync stopped');
    }
    
    /**
     * Handle coming back online
     */
    private handleOnline = (): void => {
        console.log('Back online - triggering sync');
        this.sync().catch(console.error);
    };
    
    /**
     * Perform a full sync (push + pull)
     */
    async sync(): Promise<SyncResult> {
        if (!browser || this.isSyncing) {
            return { success: false, pushed: 0, pulled: 0, errors: ['Sync skipped - already syncing'] };
        }
        
        if (!navigator.onLine) {
            console.log('[Sync] Offline - skipping sync');
            return { success: false, pushed: 0, pulled: 0, errors: ['Offline'] };
        }
        
        const storeId = getStoreId();
        const deviceId = getDeviceId();
        
        if (!storeId || !deviceId) {
            return { success: false, pushed: 0, pulled: 0, errors: ['Device not registered'] };
        }
        
        this.isSyncing = true;
        setSyncState('syncing');
        setSyncProgress(0);
        
        const result: SyncResult = {
            success: true,
            pushed: 0,
            pulled: 0,
            errors: []
        };
        
        try {
            // CRITICAL: Set store context for RLS before any database operations
            const contextSet = await setStoreContext(storeId);
            if (!contextSet) {
                console.warn('[Sync] Failed to set store context, sync may fail due to RLS');
            }
            
            // Phase 1: Push local changes (10% to 50% of progress)
            setSyncProgress(10);
            const pushResult = await this.pushChanges(storeId, deviceId, (progress) => {
                // Map push progress (0-100) to overall progress (10-50)
                setSyncProgress(10 + Math.floor(progress * 0.4));
            });
            result.pushed = pushResult.count;
            if (pushResult.errors.length > 0) {
                result.errors.push(...pushResult.errors);
            }
            setSyncProgress(50);
            
            // Phase 2: Pull remote changes (50% to 100% of progress)
            const pullResult = await this.pullChanges(storeId, (progress) => {
                // Map pull progress (0-100) to overall progress (50-100)
                setSyncProgress(50 + Math.floor(progress * 0.5));
            });
            result.pulled = pullResult.count;
            if (pullResult.errors.length > 0) {
                result.errors.push(...pullResult.errors);
            }
            setSyncProgress(100);
            
            // Determine if we should update the last sync timestamp
            const hadPreviousSync = getLastSyncTimestamp() !== null;
            const syncedData = result.pushed > 0 || result.pulled > 0;
            const hasErrors = result.errors.length > 0;
            
            // Update last sync timestamp if:
            // 1. We synced some data (pushed or pulled), OR
            // 2. We had a previous successful sync and this one completed without errors
            // This ensures first-time syncs without data will retry with full pull
            if (syncedData || (hadPreviousSync && !hasErrors)) {
                // Update last sync timestamp
                const now = new Date().toISOString();
                setLastSyncTimestamp(now);
                
                // Update device last_sync_at in Supabase
                await this.updateDeviceLastSync(deviceId);
                
                console.log(`[Sync] Complete: pushed ${result.pushed}, pulled ${result.pulled}, errors: ${result.errors.length}`);
            } else if (!hadPreviousSync && !syncedData) {
                // First sync with no data - keep timestamp null so we retry full pull
                // This handles the case where Supabase tables don't have data yet
                console.log(`[Sync] First sync found no data - will retry full pull on next sync`);
            } else {
                // Sync had errors - don't update timestamp to allow retry
                console.log(`[Sync] Completed with errors - not updating lastSync timestamp`);
            }
            
            // Set final state
            setSyncState('idle');
            
            if (result.pushed > 0) recordPush(result.pushed);
            if (result.pulled > 0) recordPull(result.pulled);
            
        } catch (error) {
            console.error('Sync failed:', error);
            result.success = false;
            result.errors.push(error instanceof Error ? error.message : 'Unknown error');
            setSyncState('error', result.errors.join(', '));
            recordSyncFailure();
        } finally {
            this.isSyncing = false;
        }
        
        return result;
    }
    
    /**
     * Push local changes to Supabase
     */
    private async pushChanges(
        storeId: string, 
        deviceId: string,
        onProgress?: (progress: number) => void
    ): Promise<{ count: number; errors: string[] }> {
        const supabase = getSupabase();
        if (!supabase || !db) {
            return { count: 0, errors: ['Database not available'] };
        }
        
        const errors: string[] = [];
        let totalPushed = 0;
        let totalProcessed = 0;
        
        try {
            // Get pending changes from local database
            const pendingChanges = await db.pendingChanges?.toArray() || [];
            const totalChanges = pendingChanges.length;
            console.log('[Sync] Push starting, pendingChanges count:', totalChanges);
            if (totalChanges > 0 && totalChanges <= 20) {
                console.log('[Sync] Pending changes:', pendingChanges.map(c => ({ table: c.tableName, action: c.action, id: c.recordId })));
            }
            
            if (totalChanges === 0) {
                onProgress?.(100);
                return { count: 0, errors: [] };
            }
            
            // Group changes by table
            const changesByTable = new Map<string, PendingChange[]>();
            for (const change of pendingChanges) {
                const existing = changesByTable.get(change.tableName) || [];
                existing.push(change);
                changesByTable.set(change.tableName, existing);
            }
            
            // Process each table
            for (const [tableName, changes] of changesByTable) {
                const supabaseTable = TABLE_NAME_MAP[tableName];
                if (!supabaseTable) {
                    console.warn(`Unknown table: ${tableName}`);
                    totalProcessed += changes.length;
                    continue;
                }
                
                // Process in batches
                let networkErrorOccurred = false;
                
                for (let i = 0; i < changes.length && !networkErrorOccurred; i += MAX_BATCH_SIZE) {
                    const batch = changes.slice(i, i + MAX_BATCH_SIZE);
                    
                    for (const change of batch) {
                        try {
                            await this.pushSingleChange(supabase, supabaseTable, change, storeId, deviceId);
                            
                            // Mark as synced
                            if (change.id && db.pendingChanges) {
                                await db.pendingChanges.delete(change.id);
                            }
                            
                            totalPushed++;
                        } catch (err: unknown) {
                            // Extract detailed error message
                            let errorDetail = 'Unknown error';
                            let isNetworkError = false;
                            
                            if (err && typeof err === 'object') {
                                const e = err as Record<string, unknown>;
                                errorDetail = e.message as string || e.error as string || JSON.stringify(e);
                                
                                // Detect network errors
                                const errorStr = errorDetail.toLowerCase();
                                isNetworkError = errorStr.includes('failed to fetch') ||
                                    errorStr.includes('network') ||
                                    errorStr.includes('err_name_not_resolved') ||
                                    errorStr.includes('err_network') ||
                                    errorStr.includes('typeerror');
                            }
                            
                            const errorMsg = `Failed to push ${change.action} to ${tableName}: ${errorDetail}`;
                            
                            // Only log network errors once, not for every record
                            if (isNetworkError) {
                                if (!errors.some(e => e.includes('network') || e.includes('Network error'))) {
                                    console.error(`[Sync] Network error - stopping sync`);
                                    errors.push(`Network error: Unable to connect to Supabase`);
                                }
                                // Mark network error to break out of all loops
                                networkErrorOccurred = true;
                                break;
                            } else {
                                console.error(errorMsg, { change, err });
                                errors.push(errorMsg);
                            }
                        }
                        
                        // Update progress
                        totalProcessed++;
                        if (onProgress && totalChanges > 0) {
                            const progress = Math.floor((totalProcessed / totalChanges) * 100);
                            // Only update every 5% to avoid too many updates
                            if (progress % 5 === 0 || totalProcessed === totalChanges) {
                                onProgress(progress);
                            }
                        }
                    }
                }
                
                // Stop processing other tables if network error occurred
                if (networkErrorOccurred) {
                    break;
                }
            }
            
            // Update pending changes count
            const remainingChanges = await db.pendingChanges?.count() || 0;
            setPendingChanges(remainingChanges);
            
            onProgress?.(100);
            
        } catch (error) {
            errors.push(`Push error: ${error}`);
        }
        
        return { count: totalPushed, errors };
    }
    
    /**
     * Push a single change to Supabase
     */
    private async pushSingleChange(
        supabase: ReturnType<typeof getSupabase>,
        tableName: string,
        change: PendingChange,
        storeId: string,
        deviceId: string
    ): Promise<void> {
        if (!supabase) throw new Error('Supabase not available');
        
        // Check if this is an auto-increment table (uses local_id mapping)
        const isAutoIncrement = isAutoIncrementTable(change.tableName);
        
        // Get field mapping for this table (handles special name conversions)
        const fieldMapping = getFieldMapping(change.tableName);
        
        // Step 1: Apply custom field mappings BEFORE snake_case conversion
        let preprocessedData = { ...change.data };
        for (const [camelKey, snakeKey] of Object.entries(fieldMapping)) {
            if (camelKey in preprocessedData) {
                // Store with the correct snake_case key, remove the original
                preprocessedData[snakeKey] = preprocessedData[camelKey];
                delete preprocessedData[camelKey];
            }
        }
        
        // Step 2: Convert remaining camelCase to snake_case
        let data = {
            ...this.convertToSnakeCase(preprocessedData),
            store_id: storeId,
            updated_at: new Date().toISOString()
        };
        
        // Step 3: Apply field exclusions for this table
        const excludedFields = getExcludedFields(tableName);
        for (const field of excludedFields) {
            delete (data as Record<string, unknown>)[field];
        }
        
        // For auto-increment tables, map the local 'id' to 'local_id' in Supabase
        if (isAutoIncrement) {
            const localId = parseInt(change.recordId, 10);
            if (!isNaN(localId)) {
                data = {
                    ...data,
                    local_id: localId
                };
                // Remove 'id' if it exists (Supabase will auto-generate UUID)
                delete (data as Record<string, unknown>).id;
            }
        }
        
        // Step 4: Sanitize all data (handles undefined, invalid UUIDs, dates, numbers, etc.)
        // Enable logging to help debug schema mismatches
        data = sanitizeDataForSupabase(data, tableName, false);
        
        // Step 5: Table-specific handling
        if (tableName === 'roles' || tableName === 'users') {
            // Ensure permissions is a valid JSON array for roles
            if (tableName === 'roles' && data.permissions) {
                // permissions should be JSONB, ensure it's an array
                if (!Array.isArray(data.permissions)) {
                    data.permissions = [];
                }
            }
        }
        
        // Special handling for journal_entries - convert lines array
        if (tableName === 'journal_entries') {
            // Ensure lines is a JSONB array
            if (!data.lines) {
                data.lines = [];
            }
            // Calculate totals if not present
            if (Array.isArray(data.lines)) {
                let totalDebit = 0;
                let totalCredit = 0;
                for (const line of data.lines as Array<{debit?: number; credit?: number}>) {
                    totalDebit += Number(line.debit || 0);
                    totalCredit += Number(line.credit || 0);
                }
                data.total_debit = totalDebit;
                data.total_credit = totalCredit;
            }
        }
        
        // Special handling for cost_consumptions - ensure type has a value
        if (tableName === 'cost_consumptions') {
            if (!data.type) {
                data.type = 'sale';
            }
        }
        
        // Note: After migration 015, shift_number is now TEXT in Supabase
        // No conversion needed - TypeScript string format "2024-001" is stored directly
        
        switch (change.action) {
            case 'insert':
            case 'update': {
                // Get the appropriate conflict key for this table
                const conflictKey = getConflictKey(tableName, isAutoIncrement);
                
                // Only log for debugging specific tables or first few records
                // console.log(`[Sync] Upserting to ${tableName} with conflict key: ${conflictKey}`);
                
                const { error, status, statusText } = await supabase
                    .from(tableName as keyof Database['public']['Tables'])
                    .upsert(data as Record<string, unknown>, { 
                        onConflict: conflictKey,
                        ignoreDuplicates: false 
                    });
                
                if (error) {
                    // Check for network-related errors first
                    const isNetworkError = !status || status === 0 || 
                        error.message?.includes('Failed to fetch') ||
                        error.message?.includes('NetworkError');
                    
                    if (isNetworkError) {
                        throw new Error(`Network error: Failed to fetch`);
                    }
                    
                    // Log detailed error information for debugging (only for non-network errors)
                    const dataFields = Object.keys(data);
                    console.error(`[Sync] Upsert error for ${tableName}:`, { 
                        error: {
                            message: error.message,
                            code: error.code,
                            details: error.details,
                            hint: error.hint
                        }, 
                        status, 
                        statusText,
                        conflictKey,
                        dataFields,
                        // Only log a sample of the data to avoid huge logs
                        dataSample: JSON.stringify(data).slice(0, 500)
                    });
                    
                    // Use logSyncOperation for structured logging
                    logSyncOperation('push', tableName, change.recordId, change.action, data, {
                        success: false,
                        error: `${error.message} (${error.code || 'unknown'})`
                    });
                    
                    throw new Error(`${error.message} (${error.code || 'unknown'})`);
                }
                break;
            }
            
            case 'delete': {
                if (isAutoIncrement) {
                    // For auto-increment tables, delete by local_id
                    const localId = parseInt(change.recordId, 10);
                    const { error } = await supabase
                        .from(tableName as keyof Database['public']['Tables'])
                        .delete()
                        .eq('local_id', localId)
                        .eq('store_id', storeId);
                    
                    if (error) throw new Error(`${error.message} (${error.code || 'unknown'})`);
                } else {
                    const { error } = await supabase
                        .from(tableName as keyof Database['public']['Tables'])
                        .delete()
                        .eq('id', change.recordId)
                        .eq('store_id', storeId);
                    
                    if (error) throw new Error(`${error.message} (${error.code || 'unknown'})`);
                }
                break;
            }
        }
        
        // Log the sync operation (ignore errors from sync_log - not critical)
        try {
            await supabase.from('sync_log').insert({
                store_id: storeId,
                device_id: deviceId,
                table_name: tableName,
                record_id: change.recordId,
                action: change.action,
                data: change.data
            });
        } catch (logErr) {
            console.warn(`[Sync] Failed to log sync operation (non-critical):`, logErr);
        }
    }
    
    /**
     * Pull remote changes from Supabase
     */
    private async pullChanges(
        storeId: string,
        onProgress?: (progress: number) => void
    ): Promise<{ count: number; errors: string[] }> {
        const supabase = getSupabase();
        if (!supabase || !db) {
            return { count: 0, errors: ['Database not available'] };
        }
        
        const errors: string[] = [];
        let totalPulled = 0;
        
        // Get last sync timestamp - use epoch for first sync to pull all data
        const lastSyncRaw = getLastSyncTimestamp();
        const isFirstSync = !lastSyncRaw;
        const lastSync = lastSyncRaw || '1970-01-01T00:00:00.000Z';
        
        console.log('[Sync] Pull starting with lastSync:', lastSync, 'storeId:', storeId, 'isFirstSync:', isFirstSync);
        
        try {
            // Pull changes for each synced table
            const totalTables = SYNCED_TABLES.length;
            let tablesProcessed = 0;
            
            for (const dexieTable of SYNCED_TABLES) {
                const supabaseTable = TABLE_NAME_MAP[dexieTable];
                if (!supabaseTable) {
                    console.log(`[Sync] Skipping ${dexieTable} - no Supabase table mapping`);
                    tablesProcessed++;
                    continue;
                }
                
                const isAutoIncrement = isAutoIncrementTable(dexieTable);
                
                try {
                    console.log(`[Sync] Pulling ${supabaseTable} where store_id=${storeId} and updated_at > ${lastSync}`);
                    const { data, error } = await supabase
                        .from(supabaseTable as keyof Database['public']['Tables'])
                        .select('*')
                        .eq('store_id', storeId)
                        .gt('updated_at', lastSync)
                        .order('updated_at', { ascending: true })
                        .limit(MAX_BATCH_SIZE);
                    
                    if (error) {
                        // Table might not exist yet - log but don't fail
                        if (this.isMissingTableError(error)) {
                            console.log(`[Sync] Table ${supabaseTable} does not exist yet, skipping`);
                            continue;
                        }
                        console.error(`[Sync] Error pulling ${supabaseTable}:`, error);
                        errors.push(`Failed to pull ${supabaseTable}: ${error.message}`);
                        continue;
                    }
                    
                    console.log(`[Sync] ${supabaseTable}: fetched ${data?.length || 0} records`);
                    
                    if (data && data.length > 0) {
                        // Convert and save to local database
                        const localTable = db.table(dexieTable);
                        
                        for (const record of data) {
                            let localRecord = this.convertToCamelCase(record);
                            
                            // For auto-increment tables, use local_id as the Dexie id
                            if (isAutoIncrement && localRecord.localId !== undefined) {
                                localRecord = {
                                    ...localRecord,
                                    id: localRecord.localId  // Map local_id back to id for Dexie
                                };
                                delete (localRecord as Record<string, unknown>).localId;
                            }
                            
                            console.log(`[Sync] Saving to local ${dexieTable}:`, localRecord.id || localRecord.name);
                            await localTable.put(localRecord);
                            totalPulled++;
                        }
                    }
                } catch (err) {
                    console.error(`[Sync] Exception pulling ${supabaseTable}:`, err);
                    errors.push(`Error pulling ${supabaseTable}: ${err}`);
                }
                
                // Update progress after each table
                tablesProcessed++;
                if (onProgress && totalTables > 0) {
                    const progress = Math.floor((tablesProcessed / totalTables) * 100);
                    onProgress(progress);
                }
            }
            
            onProgress?.(100);
        } catch (error) {
            console.error('[Sync] Pull error:', error);
            errors.push(`Pull error: ${error}`);
        }
        
        // Also check sync_log for delete operations
        try {
            console.log('[Sync] Checking sync_log for deletes since:', lastSync);
            const { data: deleteLogs, error: deleteError } = await supabase
                .from('sync_log')
                .select('*')
                .eq('store_id', storeId)
                .eq('action', 'delete')
                .gt('synced_at', lastSync)
                .order('synced_at', { ascending: true });
            
            if (deleteError) {
                if (this.isAuthError(deleteError) || this.isMissingTableError(deleteError)) {
                    console.warn('[Sync] Skipping sync_log deletes (non-critical):', deleteError);
                } else {
                    console.error('[Sync] Error fetching delete logs:', deleteError);
                    errors.push(`Failed to fetch delete logs: ${deleteError.message}`);
                }
            } else if (deleteLogs && deleteLogs.length > 0) {
                console.log('[Sync] Found', deleteLogs.length, 'delete operations to apply');
                
                for (const log of deleteLogs) {
                    // Find the corresponding Dexie table name
                    const dexieTable = Object.entries(TABLE_NAME_MAP).find(
                        ([_, supaTable]) => supaTable === log.table_name
                    )?.[0];
                    
                    if (dexieTable && db) {
                        try {
                            const localTable = db.table(dexieTable);
                            console.log(`[Sync] Deleting ${log.record_id} from local ${dexieTable}`);
                            await localTable.delete(log.record_id);
                            totalPulled++;
                        } catch (err) {
                            console.error(`[Sync] Error deleting from ${dexieTable}:`, err);
                        }
                    }
                }
            } else {
                console.log('[Sync] No delete operations found');
            }
        } catch (err) {
            console.error('[Sync] Error processing deletes:', err);
            errors.push(`Error processing deletes: ${err}`);
        }
        
        console.log('[Sync] Pull complete, totalPulled:', totalPulled);
        return { count: totalPulled, errors };
    }

    /**
     * Detect missing table errors from Supabase REST responses
     */
    private isMissingTableError(error: { code?: string; message?: string; status?: number } | null): boolean {
        if (!error) return false;
        if (error.code === '42P01') return true;
        if (error.status === 404) return true;
        return typeof error.message === 'string' && error.message.toLowerCase().includes('does not exist');
    }

    /**
     * Detect auth-related errors (anon key, RLS, missing session context)
     */
    private isAuthError(error: { status?: number; code?: string } | null): boolean {
        if (!error) return false;
        if (error.status === 401 || error.status === 403) return true;
        return error.code === 'PGRST301';
    }
    
    /**
     * Update device last_sync_at timestamp
     */
    private async updateDeviceLastSync(deviceId: string): Promise<void> {
        const supabase = getSupabase();
        if (!supabase) return;
        
        try {
            await supabase
                .from('devices')
                .update({ last_sync_at: new Date().toISOString() })
                .eq('id', deviceId);
        } catch (err) {
            console.warn('Failed to update device last_sync_at:', err);
        }
    }
    
    /**
     * Convert camelCase object keys to snake_case for Supabase
     * Handles both uppercase letters and numbers that follow lowercase letters
     */
    private convertToSnakeCase(obj: Record<string, unknown>): Record<string, unknown> {
        const result: Record<string, unknown> = {};
        
        for (const [key, value] of Object.entries(obj)) {
            // Add underscore before:
            // 1. Uppercase letters or numbers that follow lowercase letters
            // 2. Uppercase letters that follow numbers
            // Then convert entire string to lowercase
            const snakeKey = key
                .replace(/([a-z])([A-Z0-9])/g, '$1_$2')  // lowercase -> uppercase/number
                .replace(/([0-9])([A-Z])/g, '$1_$2')     // number -> uppercase
                .toLowerCase();
            result[snakeKey] = value;
        }
        
        return result;
    }
    
    /**
     * Convert snake_case object keys to camelCase for Dexie
     */
    private convertToCamelCase(obj: Record<string, unknown>): Record<string, unknown> {
        const result: Record<string, unknown> = {};
        
        for (const [key, value] of Object.entries(obj)) {
            const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
            result[camelKey] = value;
        }
        
        return result;
    }
    
    /**
     * Force a manual sync
     */
    async forceSync(): Promise<SyncResult> {
        return this.sync();
    }
    
    /**
     * Force a full sync from the beginning of time
     * Clears the last sync timestamp to pull all historical data
     */
    async forceFullSync(): Promise<SyncResult> {
        console.log('[Sync] Forcing full sync - clearing last sync timestamp');
        // Clear the timestamp in localStorage
        if (browser) {
            localStorage.removeItem('minimarket_last_sync');
        }
        return this.sync();
    }
    
    /**
     * Check if sync is currently in progress
     */
    get isCurrentlySyncing(): boolean {
        return this.isSyncing;
    }
}

// ============================================================
// SINGLETON INSTANCE
// ============================================================

const syncServiceInstance = new SyncService();

/**
 * Public Sync Service API
 * Provides a clean interface for managing sync
 */
export const syncService = {
    /**
     * Start the sync service
     */
    start: () => {
        syncServiceInstance.initialize();
    },
    
    /**
     * Stop the sync service
     */
    stop: () => {
        syncServiceInstance.stopBackgroundSync();
    },
    
    /**
     * Trigger an immediate sync
     */
    syncNow: async () => {
        return syncServiceInstance.forceSync();
    },
    
    /**
     * Force a full sync from beginning of time
     * Use this to recover data or on first device setup
     */
    forceFullSync: async () => {
        return syncServiceInstance.forceFullSync();
    },
    
    /**
     * Check if currently syncing
     */
    get isSyncing(): boolean {
        return syncServiceInstance.isCurrentlySyncing;
    }
};

// ============================================================
// HELPER FUNCTIONS
// ============================================================

/**
 * Track a local change for syncing
 * Call this when saving data to local database
 */
export async function trackChange(
    tableName: string,
    recordId: string,
    action: 'insert' | 'update' | 'delete',
    data: Record<string, unknown>
): Promise<void> {
    if (!browser || !db?.pendingChanges) return;
    
    // Check if this is a synced table
    if (!SYNCED_TABLES.includes(tableName)) return;
    
    const change: PendingChange = {
        tableName,
        recordId,
        action,
        data,
        timestamp: Date.now(),
        synced: false
    };
    
    await db.pendingChanges.add(change);
    
    // Update pending changes count
    const count = await db.pendingChanges.count();
    setPendingChanges(count);
}

/**
 * Initialize sync service (call on app startup)
 * Returns after the initial sync completes
 */
export async function initializeSyncService(): Promise<SyncResult> {
    syncService.start();
    // Wait for initial sync to complete before returning
    // This ensures data is available when pages load
    console.log('[Sync] Waiting for initial sync to complete...');
    const result = await syncService.syncNow();
    console.log('[Sync] Initial sync complete:', result);
    return result;
}

/**
 * Stop sync service (call on app shutdown)
 */
export function stopSyncService(): void {
    syncService.stopBackgroundSync();
}

/**
 * Trigger manual sync
 */
export async function triggerSync(): Promise<SyncResult> {
    return syncService.syncNow();
}

